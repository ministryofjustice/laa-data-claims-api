buildscript {
    repositories {
        mavenCentral()
    }
    dependencies {
        classpath 'org.yaml:snakeyaml:2.2'
    }
}

def exportSqlConfigFile = project.file('src/main/resources/application.yml')
def exportDefinitionsDir = project.file('src/main/resources/export_definitions')
def exportDefinitionFiles = project.fileTree(exportDefinitionsDir) {
    include '**/*.yml'
    include '**/*.yaml'
}
def exportSqlGeneratedDir = layout.buildDirectory.dir("generated/export-sql")

tasks.register('generateExportSql') {
    inputs.file(exportSqlConfigFile)
    inputs.files(exportDefinitionFiles)
    outputs.dir(exportSqlGeneratedDir)
    doLast {
        def exportDir = exportSqlGeneratedDir.get().asFile
        exportDir.mkdirs()
        def yaml = new org.yaml.snakeyaml.Yaml()
        def config = yaml.load(exportSqlConfigFile.text) ?: [:]
        def exportsConfig = config?.laa?.springboot?.starter?.exports
        if (!exportsConfig) {
            exportsConfig = config?.laa?.'springboot.starter'?.exports
        }
        if (exportsConfig?.enabled != true) {
            logger.warn("Exports disabled; skipping SQL export code generation.")
            return
        }
        def capitalizeFirst = { String value ->
            value ? value.substring(0, 1).toUpperCase() + value.substring(1) : value
        }
        def extractAliases = { String sql ->
            def keys = []
            if (sql == null) {
                return keys
            }
            def matcher = (sql =~ /(?i)\bas\s+\"?([A-Za-z_][A-Za-z0-9_]*)\"?\s*(,|\\bfrom\\b|$)/)
            matcher.each { match -> keys << match[1] }
            return keys
        }
        def filenameKey = { File file ->
            def name = file.name
            def dot = name.lastIndexOf('.')
            return dot > 0 ? name.substring(0, dot) : name
        }
        def loadDefinitionsFromFiles = { yamlParser ->
            def defs = [:]
            if (!exportDefinitionsDir.exists() || exportDefinitionFiles.isEmpty()) {
                return defs
            }
            exportDefinitionFiles.each { file ->
                def data = yamlParser.load(file.text) ?: [:]
                def nestedDefs = data?.laa?.springboot?.starter?.exports?.definitions ?: [:]
                if (!nestedDefs) {
                    nestedDefs = data?.laa?.'springboot.starter'?.exports?.definitions ?: [:]
                }
                if (nestedDefs) {
                    defs.putAll(nestedDefs)
                    return
                }
                if (data?.sql || data?.provider) {
                    defs.put(filenameKey(file), data)
                    return
                }
                if (data instanceof Map && !data.isEmpty()) {
                    defs.putAll(data)
                }
            }
            return defs
        }
        def definitions = loadDefinitionsFromFiles(yaml)
        def appDefinitions = exportsConfig?.definitions ?: [:]
        definitions.putAll(appDefinitions)
        if (definitions.isEmpty()) {
            logger.warn("No export definitions found; skipping SQL export code generation.")
            return
        }
        definitions.each { key, defn ->
            def sql = defn?.sql
            if (!sql) {
                return
            }
            if (!defn?.provider) {
                throw new GradleException("Export ${key} has sql but no provider")
            }
            def className = defn.className ?: key.split('[_-]').collect { it.capitalize() }.join('') + 'Row'
            def packageName = defn.packageName ?: 'uk.gov.justice.laa.dstew.payments.claimsdata.export.generated'
            def columns = defn.columns ?: []
            def aliasKeys = extractAliases(sql)
            def columnKeys = columns.collect { it.key }
            if (aliasKeys.isEmpty() && columnKeys.isEmpty()) {
                throw new GradleException("Export ${key} could not determine columns from SQL")
            }
            def outDir = new File(exportDir, packageName.replace('.', '/'))
            outDir.mkdirs()
            def rowSource = new StringBuilder()
            def providerSource = new StringBuilder()

            def effectiveKeys = aliasKeys.isEmpty() ? columnKeys : aliasKeys
            if (!columnKeys.isEmpty() && !aliasKeys.isEmpty()) {
                def missing = columnKeys.findAll { !aliasKeys.contains(it) }
                effectiveKeys = effectiveKeys + missing
            }
            def fields = effectiveKeys.collect { name ->
                [name: name, javaType: 'String']
            }

            rowSource << "package ${packageName};\n\n"
            rowSource << "/**\n"
            rowSource << " * Row DTO for export ${key}.\n"
            rowSource << " */\n"
            rowSource << "public class ${className} {\n"
            fields.each { f ->
                rowSource << "  private String ${f.name};\n"
            }
            rowSource << "\n  public ${className}() {\n"
            rowSource << "  }\n\n"
            fields.each { f ->
                def methodName = "get${capitalizeFirst(f.name)}"
                def setterName = "set${capitalizeFirst(f.name)}"
                rowSource << "  public String ${methodName}() {\n"
                rowSource << "    return ${f.name};\n"
                rowSource << "  }\n\n"
                rowSource << "  public void ${setterName}(String ${f.name}) {\n"
                rowSource << "    this.${f.name} = ${f.name};\n"
                rowSource << "  }\n\n"
            }
            rowSource << "}\n"

            def providerClassName = "${className}Provider"
            providerSource << "package ${packageName};\n\n"
            providerSource << "import java.sql.Timestamp;\n"
            providerSource << "import java.time.Instant;\n"
            providerSource << "import java.util.HashMap;\n"
            providerSource << "import java.util.List;\n"
            providerSource << "import java.util.Map;\n"
            providerSource << "import java.util.stream.Collectors;\n"
            providerSource << "import java.util.stream.Stream;\n"
            providerSource << "import org.springframework.jdbc.core.BeanPropertyRowMapper;\n"
            providerSource << "import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;\n"
            providerSource << "import org.springframework.stereotype.Component;\n"
            providerSource << "import uk.gov.justice.laa.export.ExportQueryProvider;\n"
            providerSource << "import uk.gov.justice.laa.export.model.ValidatedExportRequest;\n\n"
            providerSource << "/**\n"
            providerSource << " * Export provider for ${key}.\n"
            providerSource << " */\n"
            providerSource << "@Component(\"${defn.provider}\")\n"
            providerSource << "public class ${providerClassName} implements ExportQueryProvider<${className}> {\n"
            def sqlLines = sql.readLines().collect { it.replace('\\\\', '\\\\\\\\').replace('\"', '\\\\\"') }
            providerSource << "  private static final String SQL =\n"
            providerSource << "      String.join(\"\\n\",\n"
            sqlLines.eachWithIndex { line, idx ->
                def suffix = idx == sqlLines.size() - 1 ? "" : ","
                providerSource << "          \"${line}\"${suffix}\n"
            }
            providerSource << "      );\n"
            providerSource << "  private final NamedParameterJdbcTemplate jdbcTemplate;\n"
            providerSource << "  private final BeanPropertyRowMapper<${className}> rowMapper =\n"
            providerSource << "      BeanPropertyRowMapper.newInstance(${className}.class);\n\n"
            providerSource << "  public ${providerClassName}(NamedParameterJdbcTemplate jdbcTemplate) {\n"
            providerSource << "    this.jdbcTemplate = jdbcTemplate;\n"
            providerSource << "  }\n\n"
            providerSource << "  @Override\n"
            providerSource << "  public Stream<${className}> fetch(ValidatedExportRequest request) {\n"
            providerSource << "    Map<String, Object> params = normalizeParams(request.getParams());\n"
            providerSource << "    params.put(\"maxRows\", request.getMaxRows());\n"
            providerSource << "    return jdbcTemplate.queryForStream(SQL, params, rowMapper);\n"
            providerSource << "  }\n\n"
            providerSource << "  @Override\n"
            providerSource << "  public Class<${className}> rowType() {\n"
            providerSource << "    return ${className}.class;\n"
            providerSource << "  }\n\n"
            providerSource << "  private Map<String, Object> normalizeParams(Map<String, Object> raw) {\n"
            providerSource << "    Map<String, Object> params = new HashMap<>();\n"
            providerSource << "    raw.forEach((key, value) -> params.put(key, normalizeValue(value)));\n"
            providerSource << "    return params;\n"
            providerSource << "  }\n\n"
            providerSource << "  private Object normalizeValue(Object value) {\n"
            providerSource << "    if (value == null) {\n"
            providerSource << "      return null;\n"
            providerSource << "    }\n"
            providerSource << "    if (value instanceof Instant instant) {\n"
            providerSource << "      return Timestamp.from(instant);\n"
            providerSource << "    }\n"
            providerSource << "    if (value instanceof Enum<?> enumValue) {\n"
            providerSource << "      return enumValue.name();\n"
            providerSource << "    }\n"
            providerSource << "    if (value instanceof List<?> list) {\n"
            providerSource << "      return list.stream().map(this::normalizeValue).collect(Collectors.toList());\n"
            providerSource << "    }\n"
            providerSource << "    return value;\n"
            providerSource << "  }\n"
            providerSource << "\n"
            providerSource << "}\n"

            new File(outDir, "${className}.java").text = rowSource.toString()
            new File(outDir, "${providerClassName}.java").text = providerSource.toString()
        }
    }
}

sourceSets.main.java.srcDirs += exportSqlGeneratedDir
compileJava.dependsOn tasks.named('generateExportSql')
