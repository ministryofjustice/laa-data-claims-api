plugins {
    id 'io.freefair.lombok' version '8.13.1'
    id 'uk.gov.laa.springboot.laa-spring-boot-gradle-plugin'
    id "com.dorongold.task-tree" version "2.1.1"
    id("com.diffplug.spotless") version "7.2.1"
    id "io.sentry.jvm.gradle" version "5.12.2"
    id 'au.com.dius.pact' version '4.6.19'
}

def versions = [
        sentry        : '8.28.0',
        testcontainers: '1.20.1'
]

test {
    useJUnitPlatform()
    finalizedBy jacocoTestReport
}

jacocoTestReport {
    afterEvaluate {
        classDirectories.setFrom(files(classDirectories.files.collect {
            fileTree(dir: it, exclude: ['**/ClaimsDataApplication.class'])
        }))
    }
}

jacocoTestCoverageVerification {
    afterEvaluate {
        classDirectories.setFrom(files(classDirectories.files.collect {
            fileTree(dir: it, exclude: ['**/ClaimsDataApplication.class'])
        }))
    }
}

// Dependency overrides
// example:
// Upgrade to fix CVE-xxxx-xxxxx
// ext['dependency-name.version'] = 'x.x.x'
ext['commons-lang3.version'] = '3.18.0'

dependencyManagement {
    dependencies {
        dependencySet(group: 'io.sentry', version: versions.sentry) {
            entry 'sentry-spring-boot-starter'
            entry 'sentry-logback'
        }
    }
}

dependencies {
    // Upgrade to fix CVE-2026-1225 vulnerability in logback-core
    implementation 'ch.qos.logback:logback-core:1.5.25'
    implementation 'ch.qos.logback:logback-classic:1.5.25'

    implementation project(':claims-data:api')

    //Enable access token authentication
    implementation 'uk.gov.laa.springboot:laa-spring-boot-starter-auth'
    //Common exception handling
    implementation 'uk.gov.laa.springboot:laa-spring-boot-starter-application-exception'
    //If the ScanForSql annotation is used, the values will be checked and a warning logged if suspicious SQL-like commands are found in any values
    implementation 'uk.gov.laa.springboot:laa-spring-boot-starter-sql-scanner'
    implementation 'org.springframework.boot:spring-boot-starter-aspectj'

    implementation 'org.springframework.boot:spring-boot-starter-actuator'
    implementation 'io.micrometer:micrometer-registry-prometheus'

    implementation 'org.springframework.boot:spring-boot-starter-data-jpa'
    implementation 'org.springframework.boot:spring-boot-starter-validation'
    implementation 'org.springframework.boot:spring-boot-starter-webmvc'
    implementation 'org.springframework.boot:spring-boot-starter-webflux'
    implementation 'org.springframework.boot:spring-boot-starter-flyway'

    implementation 'io.micrometer:micrometer-tracing-bridge-brave'
    implementation 'jakarta.validation:jakarta.validation-api:3.1.1'
    compileOnly 'org.projectlombok:lombok:1.18.38'
    annotationProcessor 'org.projectlombok:lombok:1.18.38'
    testCompileOnly 'org.projectlombok:lombok:1.18.38'
    testAnnotationProcessor 'org.projectlombok:lombok:1.18.38'
    implementation 'org.springdoc:springdoc-openapi-starter-webmvc-ui:2.8.8'
    implementation 'org.mapstruct:mapstruct:1.6.3'
    implementation 'org.javers:javers-spring-boot-starter-sql:7.10.0'
    implementation platform('com.fasterxml.jackson:jackson-bom:2.19.2')
    implementation 'com.fasterxml.jackson.dataformat:jackson-dataformat-xml'
    implementation 'com.fasterxml.jackson.dataformat:jackson-dataformat-csv'
    implementation 'com.fasterxml.jackson.datatype:jackson-datatype-jsr310'
    implementation 'com.fasterxml.uuid:java-uuid-generator:5.1.0'
    implementation platform("software.amazon.awssdk:bom:2.32.22")
    implementation "software.amazon.awssdk:sqs"
    implementation 'software.amazon.awssdk:sts'
    implementation 'io.github.resilience4j:resilience4j-spring-boot3:2.1.0'

    // Sentry
    implementation platform("io.sentry:sentry-bom:$versions.sentry")
    implementation "io.sentry:sentry-logback:$versions.sentry"
    implementation "io.sentry:sentry-spring-boot-4:$versions.sentry"

    // XML Output
    implementation platform("org.glassfish.jaxb:jaxb-bom:4.0.5")
    implementation "jakarta.xml.bind:jakarta.xml.bind-api"
    implementation "org.glassfish.jaxb:jaxb-runtime"

    annotationProcessor 'org.mapstruct:mapstruct-processor:1.6.3'

    runtimeOnly "org.flywaydb:flyway-database-postgresql"
    runtimeOnly 'org.postgresql:postgresql'

    testImplementation 'org.springframework.boot:spring-boot-starter-test'
    testImplementation 'org.springframework.boot:spring-boot-starter-webmvc-test'
    testImplementation 'org.springframework.boot:spring-boot-starter-security-test'
    testImplementation "org.testcontainers:junit-jupiter:$versions.testcontainers"
    testImplementation 'org.springframework.boot:spring-boot-testcontainers'
    // Add this to ensure Spring Security classes are available during tests
    testImplementation 'org.springframework.security:spring-security-test'
    testImplementation "org.testcontainers:postgresql:$versions.testcontainers"
    testImplementation "org.testcontainers:localstack:$versions.testcontainers"
    testRuntimeOnly 'org.junit.platform:junit-platform-launcher'
    testRuntimeOnly "org.flywaydb:flyway-database-postgresql"

    developmentOnly 'org.springframework.boot:spring-boot-devtools'

    testRuntimeOnly "org.flywaydb:flyway-database-postgresql"
}

sourceSets {
    pactTest {
        java {
            compileClasspath += main.output + test.output
            runtimeClasspath += main.output + test.output
        }
    }
}

configurations {
    compileOnly {
        extendsFrom annotationProcessor
    }
    pactTestImplementation.extendsFrom(testImplementation)
    pactTestRuntimeOnly.extendsFrom(testRuntimeOnly)
}


dependencies {
    // Source: https://mvnrepository.com/artifact/au.com.dius.pact.provider/spring7
    pactTestImplementation 'au.com.dius.pact.provider:spring7:4.7.0-beta.3'
    pactTestImplementation 'org.springframework.boot:spring-boot-starter-test'
    pactTestImplementation 'org.springframework.boot:spring-boot-autoconfigure'
    pactTestImplementation 'org.springframework.boot:spring-boot-starter-data-jpa'
    pactTestImplementation 'org.apache.httpcomponents:httpclient:4.5.13'
}

tasks.register('pactTest', Test) {
    description = 'Runs the pact tests.'
    group = 'verification'
    useJUnitPlatform()

    testClassesDirs = sourceSets.pactTest.output.classesDirs
    classpath = sourceSets.pactTest.runtimeClasspath

    // Publish if both username and password environment variables are provided
    def canPublish =
            providers.environmentVariable('PACT_BROKER_USERNAME').isPresent() &&
            providers.environmentVariable('PACT_BROKER_PASSWORD').isPresent()

    if (canPublish) {
        systemProperty 'pact.verifier.publishResults', 'true'
    }

    // Pass environment variables into the test process as System Properties
    systemProperty 'pact.provider.version', providers.environmentVariable('CI_COMMIT_SHA').getOrElse('1.0.0')
    systemProperty 'pactbroker.url', providers.environmentVariable('PACT_BROKER_URL').getOrElse('https://laa-data-pact-broker.apps.live.cloud-platform.service.justice.gov.uk/')
    systemProperty 'pactbroker.auth.username', providers.environmentVariable('PACT_BROKER_USERNAME').getOrElse('ABC')
    systemProperty 'pactbroker.auth.password', providers.environmentVariable('PACT_BROKER_PASSWORD').getOrElse('ABC')

    // Only set the consumer filter and branch selectors if PACT_CONSUMER_NAME is provided
    def consumerName = providers.environmentVariable('PACT_CONSUMER_NAME').orNull

    if (consumerName) {
        systemProperty 'pact.filter.consumers', consumerName
    }
    def branch = providers.environmentVariable('PACT_CONSUMER_BRANCH').getOrElse('main')
    systemProperty 'pactbroker.consumerversionselectors.rawjson', "[{\"branch\":\"${branch}\"}]"

    // Resolve the directory path to a String for the system property
    systemProperty 'pact.rootDir', layout.buildDirectory.dir("pacts").get().asFile.path
}

tasks.named('processPactTestResources') {
    duplicatesStrategy = DuplicatesStrategy.INCLUDE
}

spotless {
    java {
        target 'src/*/java/**/*.java'
        importOrder()
        removeUnusedImports()
        cleanthat()
        googleJavaFormat()
    }
}

tasks.register("checkstyleStaged", Checkstyle) {
    group = "verification"
    description = "Runs Checkstyle on staged files only"

    def filesToCheck = project.findProperty("checkstyleFiles")
    if (filesToCheck != null) {
        source = files(filesToCheck.split(","))
    } else {
        source = sourceSets.main.allJava
    }

    classpath = sourceSets.main.compileClasspath
}

// Outcome item names extracted from XmlOutcomeDeserializer
def outcomeItems = [
    "FEE_CODE", "CASE_REF_NUMBER", "CASE_START_DATE", "CASE_ID", "CASE_STAGE_LEVEL",
    "UFN", "PROCUREMENT_AREA", "ACCESS_POINT", "CLIENT_FORENAME", "CLIENT_SURNAME",
    "CLIENT_DATE_OF_BIRTH", "UCN", "CLA_REF_NUMBER", "CLA_EXEMPTION", "GENDER",
    "ETHNICITY", "DISABILITY", "CLIENT_POST_CODE", "WORK_CONCLUDED_DATE", "ADVICE_TIME",
    "TRAVEL_TIME", "WAITING_TIME", "PROFIT_COST", "VALUE_OF_COSTS", "DISBURSEMENTS_AMOUNT",
    "COUNSEL_COST", "DISBURSEMENTS_VAT", "TRAVEL_WAITING_COSTS", "VAT_INDICATOR", "LONDON_NONLONDON_RATE",
    "CLIENT_TYPE", "TOLERANCE_INDICATOR", "TRAVEL_COSTS", "OUTCOME_CODE", "LEGACY_CASE",
    "CLAIM_TYPE", "ADJOURNED_HEARING_FEE", "TYPE_OF_ADVICE", "POSTAL_APPL_ACCP", "SCHEDULE_REF",
    "CMRH_ORAL", "CMRH_TELEPHONE", "AIT_HEARING_CENTRE", "SUBSTANTIVE_HEARING", "HO_INTERVIEW",
    "HO_UCN", "TRANSFER_DATE", "DETENTION_TRAVEL_WAITING_COSTS", "DELIVERY_LOCATION", "PRIOR_AUTHORITY_REF",
    "JR_FORM_FILLING", "ADDITIONAL_TRAVEL_PAYMENT", "MEETINGS_ATTENDED", "MEDICAL_REPORTS_CLAIMED", "DESI_ACC_REP",
    "MHT_REF_NUMBER", "STAGE_REACHED", "FOLLOW_ON_WORK", "NATIONAL_REF_MECHANISM_ADVICE", "EXEMPTION_CRITERIA_SATISFIED",
    "EXCL_CASE_FUNDING_REF", "NO_OF_CLIENTS", "NO_OF_SURGERY_CLIENTS", "IRC_SURGERY", "SURGERY_DATE",
    "LINE_NUMBER", "CRIME_MATTER_TYPE", "FEE_SCHEME", "REP_ORDER_DATE", "NO_OF_SUSPECTS",
    "NO_OF_POLICE_STATION", "POLICE_STATION", "DSCC_NUMBER", "MAAT_ID", "DUTY_SOLICITOR",
    "YOUTH_COURT", "SCHEME_ID", "NUMBER_OF_MEDIATION_SESSIONS", "MEDIATION_TIME", "OUTREACH",
    "REFERRAL", "CLIENT_LEGALLY_AIDED", "CLIENT2_FORENAME", "CLIENT2_SURNAME", "CLIENT2_DATE_OF_BIRTH",
    "CLIENT2_UCN", "CLIENT2_POST_CODE", "CLIENT2_GENDER", "CLIENT2_ETHNICITY", "CLIENT2_DISABILITY",
    "CLIENT2_LEGALLY_AIDED", "UNIQUE_CASE_ID", "STANDARD_FEE_CAT", "CLIENT2_POSTAL_APPL_ACCP", "COSTS_DAMAGES_RECOVERED",
    "ELIGIBLE_CLIENT_INDICATOR", "COURT_LOCATION_HPCDS", "LOCAL_AUTHORITY_NUMBER", "PA_NUMBER", "EXCESS_TRAVEL_COSTS",
    "MED_CONCLUDED_DATE"
]

tasks.register('generateXsd') {
    group = 'build'
    description = 'Generates professional third-party XSD from Jackson-annotated XML model classes'

    def outputDir = file("$buildDir/generated/xsd")

    inputs.files(sourceSets.main.output)
    outputs.dir(outputDir)

    dependsOn tasks.named('classes')

    doLast {
        outputDir.mkdirs()

        // Get git version for schema
        def gitVersion = "git rev-parse --short HEAD".execute().text.trim()

        // Create a URL ClassLoader
        def classPathUrls = []
        sourceSets.main.output.classesDirs.files.forEach { classPathUrls.add(it.toURI().toURL()) }
        project(':claims-data:api').sourceSets.main.output.classesDirs.files.forEach { classPathUrls.add(it.toURI().toURL()) }
        configurations.compileClasspath.forEach { classPathUrls.add(it.toURI().toURL()) }

        def classPath = classPathUrls.toArray(new java.net.URL[0]) as java.net.URL[]
        def classLoader = new java.net.URLClassLoader(classPath, Thread.currentThread().getContextClassLoader())
        Thread.currentThread().setContextClassLoader(classLoader)

        // Load annotation and Jackson classes
        def xsdDocAnnotation = classLoader.loadClass("uk.gov.justice.laa.dstew.payments.claimsdata.annotation.XsdDocumentation")
        def jacksonXmlRootElement = classLoader.loadClass("com.fasterxml.jackson.dataformat.xml.annotation.JacksonXmlRootElement")
        def jacksonXmlProperty = classLoader.loadClass("com.fasterxml.jackson.dataformat.xml.annotation.JacksonXmlProperty")

        // Load XML model classes
        def xmlClasses = [
            classLoader.loadClass("uk.gov.justice.laa.dstew.payments.claimsdata.model.xml.XmlSubmission"),
            classLoader.loadClass("uk.gov.justice.laa.dstew.payments.claimsdata.model.xml.XmlOffice"),
            classLoader.loadClass("uk.gov.justice.laa.dstew.payments.claimsdata.model.xml.XmlSchedule"),
            classLoader.loadClass("uk.gov.justice.laa.dstew.payments.claimsdata.model.xml.XmlOutcome"),
            classLoader.loadClass("uk.gov.justice.laa.dstew.payments.claimsdata.model.xml.XmlMatterStarts"),
            classLoader.loadClass("uk.gov.justice.laa.dstew.payments.claimsdata.model.xml.XmlImmigrationClr")
        ]

        def namespace = "http://www.legalservices.gov.uk/sms/ActivityManagement/XMLSchema/"
        def schemaFileName = "LSCSMSBulkLoadSchema-${gitVersion}.xsd"

        // Build XSD
        def xsdBuilder = new StringBuilder()
        xsdBuilder.append('<?xml version="1.0" encoding="UTF-8"?>\n')
        xsdBuilder.append('<!--\n')
        xsdBuilder.append('  LAA Claims Data XML Schema\n')
        xsdBuilder.append('  Generated from: git ' + gitVersion + '\n')
        xsdBuilder.append('  Namespace: ' + namespace + '\n\n')
        xsdBuilder.append('  Usage:\n')
        xsdBuilder.append('  <submission xmlns="' + namespace + '"\n')
        xsdBuilder.append('              xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n')
        xsdBuilder.append('              xsi:schemaLocation="' + namespace + '\n')
        xsdBuilder.append('                                  ' + schemaFileName + '">\n')
        xsdBuilder.append('-->\n')
        xsdBuilder.append('<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema"\n')
        xsdBuilder.append('           targetNamespace="' + namespace + '"\n')
        xsdBuilder.append('           elementFormDefault="qualified"\n')
        xsdBuilder.append('           version="' + gitVersion + '">\n\n')

        // Define outcomeItem type with enumeration
        xsdBuilder.append('  <!-- Outcome items contain name attribute and text value -->\n')
        xsdBuilder.append('  <xs:complexType name="outcomeItemType">\n')
        xsdBuilder.append('    <xs:simpleContent>\n')
        xsdBuilder.append('      <xs:extension base="xs:string">\n')
        xsdBuilder.append('        <xs:attribute name="name" use="required">\n')
        xsdBuilder.append('          <xs:annotation>\n')
        xsdBuilder.append('            <xs:documentation>Outcome field identifier</xs:documentation>\n')
        xsdBuilder.append('          </xs:annotation>\n')
        xsdBuilder.append('          <xs:simpleType>\n')
        xsdBuilder.append('            <xs:restriction base="xs:string">\n')
        outcomeItems.each { item ->
            xsdBuilder.append('              <xs:enumeration value="' + item + '"/>\n')
        }
        xsdBuilder.append('            </xs:restriction>\n')
        xsdBuilder.append('          </xs:simpleType>\n')
        xsdBuilder.append('        </xs:attribute>\n')
        xsdBuilder.append('      </xs:extension>\n')
        xsdBuilder.append('    </xs:simpleContent>\n')
        xsdBuilder.append('  </xs:complexType>\n\n')

        // Generate complex types and elements for each class
        xmlClasses.each { clazz ->
            def rootElem = clazz.getAnnotation(jacksonXmlRootElement)
            if (rootElem != null) {
                def elemName = rootElem.localName()
                def typeName = elemName.capitalize() + "Type"

                // Generate complex type
                xsdBuilder.append('  <xs:complexType name="' + typeName + '">\n')
                xsdBuilder.append('    <xs:sequence>\n')

                def components = clazz.getRecordComponents()
                if (components != null) {
                    components.each { component ->
                        def field = clazz.getDeclaredField(component.name)
                        def propAnnot = field.getAnnotation(jacksonXmlProperty)
                        def docAnnot = field.getAnnotation(xsdDocAnnotation)

                        if (propAnnot == null || !propAnnot.isAttribute()) {
                            def typeStr = getXsdType(component.genericType.toString())
                            def required = docAnnot != null && docAnnot.required()
                            def minOccurs = required ? '' : ' minOccurs="0"'

                            if (elemName == 'outcome' && component.name == 'matterType') {
                                // Skip matterType from sequence, it's an attribute
                            } else {
                                xsdBuilder.append('      <xs:element name="' + component.name + '" type="' + typeStr + '"' + minOccurs + '>\n')
                                if (docAnnot != null && docAnnot.description()) {
                                    xsdBuilder.append('        <xs:annotation>\n')
                                    xsdBuilder.append('          <xs:documentation>' + docAnnot.description() + '</xs:documentation>\n')
                                    xsdBuilder.append('        </xs:annotation>\n')
                                }
                                xsdBuilder.append('      </xs:element>\n')
                            }
                        }
                    }
                }

                xsdBuilder.append('    </xs:sequence>\n')

                // Add attributes
                if (components != null) {
                    components.each { component ->
                        def field = clazz.getDeclaredField(component.name)
                        def propAnnot = field.getAnnotation(jacksonXmlProperty)
                        def docAnnot = field.getAnnotation(xsdDocAnnotation)

                        if (propAnnot != null && propAnnot.isAttribute()) {
                            def typeStr = getXsdType(component.genericType.toString())
                            def required = docAnnot != null && docAnnot.required()
                            def use = required ? 'required' : 'optional'

                            xsdBuilder.append('    <xs:attribute name="' + component.name + '" type="' + typeStr + '" use="' + use + '">\n')
                            if (docAnnot != null && docAnnot.description()) {
                                xsdBuilder.append('      <xs:annotation>\n')
                                xsdBuilder.append('        <xs:documentation>' + docAnnot.description() + '</xs:documentation>\n')
                                xsdBuilder.append('      </xs:annotation>\n')
                            }
                            xsdBuilder.append('    </xs:attribute>\n')
                        }
                    }
                }

                xsdBuilder.append('  </xs:complexType>\n\n')

                // Generate root element
                xsdBuilder.append('  <xs:element name="' + elemName + '" type="' + typeName + '">\n')
                xsdBuilder.append('    <xs:annotation>\n')
                xsdBuilder.append('      <xs:documentation>Root element for ' + elemName + '</xs:documentation>\n')
                xsdBuilder.append('    </xs:annotation>\n')
                xsdBuilder.append('  </xs:element>\n\n')
            }
        }

        xsdBuilder.append('</xs:schema>\n')

        // Write XSD file with version in name
        def xsdFile = new File(outputDir, schemaFileName)
        xsdFile.text = xsdBuilder.toString()
        println("Generated XSD: ${xsdFile.absolutePath}")

        // Also create a copy without version for convenience
        def symlinkFile = new File(outputDir, "LSCSMSBulkLoadSchema.xsd")
        symlinkFile.text = xsdBuilder.toString()
        println("Also created: ${symlinkFile.absolutePath}")
    }
}

// Helper method for XSD type mapping
def getXsdType(String javaType) {
    if (javaType.contains("List") || javaType.contains("java.util.List")) {
        return "outcomeItemType"  // For outcome items list
    } else if (javaType.contains("XmlOutcome")) {
        return "outcomeType"
    } else if (javaType.contains("XmlMatterStarts")) {
        return "matterStartsType"
    } else if (javaType.contains("XmlImmigrationClr")) {
        return "immigrationClrType"
    } else if (javaType.contains("XmlSchedule")) {
        return "scheduleType"
    } else if (javaType.contains("String")) {
        return "xs:string"
    } else if (javaType.contains("Integer")) {
        return "xs:integer"
    } else {
        return "xs:string"
    }
}

tasks.named('check') {
    dependsOn 'generateXsd'
}

tasks.register('syncXsd', Copy) {
    from "$buildDir/generated/xsd"
    into "src/main/resources/schema"
}

tasks.named('generateXsd') {
    finalizedBy 'syncXsd'
}
