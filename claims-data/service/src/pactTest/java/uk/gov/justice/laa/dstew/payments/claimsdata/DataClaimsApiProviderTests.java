package uk.gov.justice.laa.dstew.payments.claimsdata;

import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.doThrow;
import static org.mockito.Mockito.when;
import static uk.gov.justice.laa.dstew.payments.claimsdata.util.ClaimsDataTestUtil.BULK_SUBMISSION_ID;
import static uk.gov.justice.laa.dstew.payments.claimsdata.util.ClaimsDataTestUtil.SUBMISSION_ID;
import static uk.gov.justice.laa.dstew.payments.claimsdata.util.ClaimsDataTestUtil.getBulkSubmissionMatterStartMediationType;
import static uk.gov.justice.laa.dstew.payments.claimsdata.util.ClaimsDataTestUtil.getBulkSubmissionOffice;
import static uk.gov.justice.laa.dstew.payments.claimsdata.util.ClaimsDataTestUtil.getBulkSubmissionOutcome;
import static uk.gov.justice.laa.dstew.payments.claimsdata.util.ClaimsDataTestUtil.getBulkSubmissionSchedule;
import static uk.gov.justice.laa.dstew.payments.claimsdata.util.ClaimsDataTestUtil.getCalculatedFeeDetail;
import static uk.gov.justice.laa.dstew.payments.claimsdata.util.ClaimsDataTestUtil.getClaim;
import static uk.gov.justice.laa.dstew.payments.claimsdata.util.ClaimsDataTestUtil.getClaimCase;
import static uk.gov.justice.laa.dstew.payments.claimsdata.util.ClaimsDataTestUtil.getClaimSummaryFee;
import static uk.gov.justice.laa.dstew.payments.claimsdata.util.ClaimsDataTestUtil.getClient;
import static uk.gov.justice.laa.dstew.payments.claimsdata.util.ClaimsDataTestUtil.getMatterStart;
import static uk.gov.justice.laa.dstew.payments.claimsdata.util.ClaimsDataTestUtil.getSubmission;
import static uk.gov.justice.laa.dstew.payments.claimsdata.util.ClaimsDataTestUtil.getValidationMessage;

import au.com.dius.pact.provider.junit5.HttpTestTarget;
import au.com.dius.pact.provider.junit5.PactVerificationContext;
import au.com.dius.pact.provider.junit5.PactVerificationInvocationContextProvider;
import au.com.dius.pact.provider.junitsupport.Provider;
import au.com.dius.pact.provider.junitsupport.State;
import au.com.dius.pact.provider.junitsupport.TargetRequestFilter;
import au.com.dius.pact.provider.junitsupport.loader.PactBroker;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import lombok.extern.slf4j.Slf4j;
import org.apache.http.HttpRequest;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.TestTemplate;
import org.junit.jupiter.api.extension.ExtendWith;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.boot.test.context.SpringBootTest.WebEnvironment;
import org.springframework.boot.test.web.server.LocalServerPort;
import org.springframework.data.domain.Example;
import org.springframework.data.domain.PageImpl;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.domain.Specification;
import org.springframework.test.context.ActiveProfiles;
import uk.gov.justice.laa.dstew.payments.claimsdata.exception.BulkSubmissionNotFoundException;
import uk.gov.justice.laa.dstew.payments.claimsdata.exception.BulkSubmissionValidationException;
import uk.gov.justice.laa.dstew.payments.claimsdata.exception.ClaimBadRequestException;
import uk.gov.justice.laa.dstew.payments.claimsdata.exception.SubmissionBadRequestException;
import uk.gov.justice.laa.dstew.payments.claimsdata.model.BulkSubmissionErrorCode;
import uk.gov.justice.laa.dstew.payments.claimsdata.model.BulkSubmissionStatus;
import uk.gov.justice.laa.dstew.payments.claimsdata.model.CreateBulkSubmission201Response;
import uk.gov.justice.laa.dstew.payments.claimsdata.model.GetBulkSubmission200Response;
import uk.gov.justice.laa.dstew.payments.claimsdata.model.GetBulkSubmission200ResponseDetails;
import uk.gov.justice.laa.dstew.payments.claimsdata.model.ValidationMessageType;

/**
 * Unit tests for the {@code DataClaimsApiProvider} using Pact for consumer-driven contract testing.
 * This class extends {@code AbstractProviderPactTests} to inherit common test setups and
 * configurations.
 *
 * <p>The tests are started with the single method annoted with {@code @TestTemplate} annotation.
 *
 * <p>Pulls all pacts which are published on the cloud platform <a
 * href="https://laa-data-pact-broker.apps.live.cloud-platform.service.justice.gov.uk/">Pact
 * Broker</a> service which are tagged with the provider name 'laa-data-claims-api'. These pacts
 * have been generated by various dependent services as part of their own testing and development
 * processes.
 *
 * <p>Pacts which are automatically pulled from the Pact Broker service, and are detailed with
 * various states they expect the Claims API. These have all been detailed within this test class
 * using methods annotated with {@code @State} to set up the necessary conditions for each test
 * scenario.
 *
 * <p>By the nature of where test scenarios are published, this also means that these pacts are
 * regularly updated and maintained by the dependent services, ensuring that the Claims API remains
 * compatible with the latest requirements and changes.
 *
 * <p>By default, all consumer pacts published under their own respected 'main' branch is pulled
 * from the Pact Broker, however these can be overriden using two environment variables:
 *
 * <ul>
 *   <li>{@code PACT_CONSUMER_NAME} - The name of the consumer (can be found on pact broker).
 *   <li>{@code PACT_CONSUMER_BRANCH} - The name of the branch to filter pacts by, defaults to
 *       'main'.
 * </ul>
 *
 * @author Jamie Briggs
 */
@Slf4j
@ActiveProfiles("test")
@SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT)
@Provider(value = "laa-data-claims-api")
@PactBroker
public class DataClaimsApiProviderTests extends AbstractProviderPactTests {

  @LocalServerPort private int port;

  @BeforeEach
  void setUp(PactVerificationContext context) {
    HttpTestTarget target = new HttpTestTarget("localhost", port);
    context.setTarget(target);
  }

  @State("the system is ready to process a valid bulk submission")
  public void setupBulkSubmissionState() {
    log.info("Setting up state: the system is ready to process a valid bulk submission");
    when(bulkSubmissionService.submitBulkSubmissionFile(any(), any(), any()))
        .thenReturn(
            CreateBulkSubmission201Response.builder()
                .bulkSubmissionId(BULK_SUBMISSION_ID)
                .submissionIds(Arrays.asList(SUBMISSION_ID))
                .build());
  }

  @State("the system is ready to update a bulk submission")
  public void theSystemIsReadyToUpdateABulkSubmission() {
    log.info("Setting up state: the system is ready to update a bulk submission");
    when(bulkSubmissionRepository.updateBulkSubmission(any(), any(), any(), any(), any()))
        .thenReturn(1);
  }

  @State("the system is ready to update a submission")
  public void theSystemIsReadyToUpdateASubmission() {
    log.info("Setting up state: the system is ready to update a submission");
    when(submissionRepository.findById(any())).thenReturn(Optional.of(getSubmission()));
    when(submissionRepository.update(any())).thenReturn(1L);
  }

  @State("the system is ready to update a claim")
  public void theSystemIsReadyToUpdateAClaim() {
    log.info("Setting up state: the system is ready to update a claim");
    when(claimRepository.findByIdAndSubmissionId(any(), any()))
        .thenReturn(Optional.ofNullable(getClaim()));
    when(claimRepository.update(any())).thenReturn(1L);
  }

  @State("the system is ready to process a valid claim")
  public void theSystemIsReadyToProcessAValidClaim() {
    log.info("Setting up state: the system is ready to process a valid claim");
    when(submissionRepository.findById(any())).thenReturn(Optional.of(getSubmission()));
  }

  @State("the system is ready to process a valid matter start")
  public void theSystemIsReadyToProcessAValidMatterStart() {
    log.info("Setting up state: the system is ready to process a valid matter start");
    when(submissionRepository.findById(any())).thenReturn(Optional.of(getSubmission()));
  }

  @State("the system is ready to process a valid submission")
  public void theSystemIsReadyToProcessAValidSubmission() {
    log.info("No setup needed: the system is ready to process a valid submission");
  }

  @State("the system rejects an invalid submission")
  public void theSystemRejectsAnInvalidSubmission() {
    log.info("Setting up state: the system rejects an invalid submission");
    doThrow(new SubmissionBadRequestException("Error found"))
        .when(submissionRepository)
        .save(any());
  }

  @State("the submission file contains invalid data")
  public void theSubmissionFileContainsInvalidData() {
    log.info("Setting up state: the submission file contains invalid data");
    doThrow(new BulkSubmissionValidationException("Error found"))
        .when(bulkSubmissionService)
        .submitBulkSubmissionFile(any(), any(), any());
  }

  @State("the bulk submission patch contains invalid data")
  public void theBulkSubmissionPatchContainsInvalidData() {
    log.info("Setting up state: the bulk submission patch contains invalid data");
    doThrow(new BulkSubmissionValidationException("Error found"))
        .when(bulkSubmissionService)
        .updateBulkSubmission(any(), any());
  }

  @State("the submission patch contains invalid data")
  public void theSubmissionPatchContainsInvalidData() {
    log.info("Setting up state: the submission patch contains invalid data");
    when(submissionRepository.findById(any())).thenReturn(Optional.of(getSubmission()));
    doThrow(new SubmissionBadRequestException("Error found"))
        .when(submissionRepository)
        .save(any());
  }

  @State("the claim patch contains invalid data")
  public void theClaimPatchContainsInvalidData() {
    log.info("Setting up state: the claim patch contains invalid data");
    when(claimRepository.findByIdAndSubmissionId(any(), any()))
        .thenReturn(Optional.ofNullable(getClaim()));
    doThrow(new ClaimBadRequestException("Error found")).when(claimRepository).save(any());
  }

  @State("the claim request contains invalid data")
  public void theClaimRequestContainsInvalidData() {
    log.info("Setting up state: the claim request contains invalid data");
    when(submissionRepository.findById(any())).thenReturn(Optional.of(getSubmission()));
    doThrow(new ClaimBadRequestException("Error found")).when(claimRepository).save(any());
  }

  @State("the matter start request contains invalid data")
  public void theMatterStartRequestContainsInvalidData() {
    log.info("Setting up state: the matter start request contains invalid data");
    when(submissionRepository.findById(any())).thenReturn(Optional.of(getSubmission()));
    doThrow(new BulkSubmissionValidationException("Error found"))
        .when(matterStartRepository)
        .save(any());
  }

  @State("no bulk submission exists")
  public void noBulkSubmissionExists() {
    log.info("Setting up state: no bulk submission exists");
    doThrow(new BulkSubmissionNotFoundException("Not found"))
        .when(bulkSubmissionService)
        .getBulkSubmission(any());
  }

  @State("no submission exists")
  public void noSubmissionExists() {
    log.info("Setting up state: no submission exists");
    when(submissionRepository.findById(any())).thenReturn(Optional.empty());
    when(submissionRepository.findAll(any(Specification.class), any(Pageable.class)))
        .thenReturn(new PageImpl(Collections.emptyList()));
    when(claimRepository.findById(any())).thenReturn(Optional.empty());
    when(matterStartRepository.findBySubmissionIdAndId(any(), any())).thenReturn(Optional.empty());
  }

  @State("no claim exists")
  public void noClaimExists() {
    log.info("Setting up state: no claim exists");
    when(claimRepository.findById(any())).thenReturn(Optional.empty());
  }

  @State("a matter start exists")
  public void aMatterStartExists() {
    log.info("Setting up state: a matter start exists");
    when(matterStartRepository.findBySubmissionIdAndId(any(), any()))
        .thenReturn(Optional.of(getMatterStart()));
  }

  @State("no matter starts exists")
  public void noMatterStarts() {
    log.info("Setting up state: no matter starts exists");
    when(matterStartRepository.findBySubmissionIdAndId(any(), any())).thenReturn(Optional.empty());
    when(matterStartRepository.findBySubmissionId(any())).thenReturn(Collections.emptyList());
  }

  @State("a bulk submission exists")
  public void aBulkSubmissionExists() {
    log.info("Setting up state: a bulk submission exists");
    when(bulkSubmissionService.getBulkSubmission(any()))
        .thenReturn(
            GetBulkSubmission200Response.builder()
                .bulkSubmissionId(BULK_SUBMISSION_ID)
                .details(
                    new GetBulkSubmission200ResponseDetails()
                        .office(getBulkSubmissionOffice())
                        .schedule(getBulkSubmissionSchedule())
                        .outcomes(List.of(getBulkSubmissionOutcome(Boolean.TRUE)))
                        .matterStarts(List.of(getBulkSubmissionMatterStartMediationType()))
                        .immigrationClr(
                            List.of(
                                Map.of("additionalProp1", "string", "additionalProp2", "string"))))
                .createdByUserId("test-user-id")
                .errorCode(BulkSubmissionErrorCode.P100)
                .status(BulkSubmissionStatus.READY_FOR_PARSING)
                .updatedByUserId("event-service")
                .errorDescription("test-description")
                .build());
  }

  @State("a submission exists")
  public void aSubmissionExists() {
    log.info("Setting up state: a submission exists");
    when(submissionRepository.findById(any())).thenReturn(Optional.of(getSubmission()));
    when(claimRepository.findBySubmissionId(any())).thenReturn(Arrays.asList(getClaim()));
  }

  @State("a claim exists")
  public void aClaimExists() {
    log.info("Setting up state: a claim exists");
    when(claimRepository.findByIdAndSubmissionId(any(), any()))
        .thenReturn(Optional.ofNullable(getClaim()));
    when(clientRepository.findByClaimId(any())).thenReturn(Optional.ofNullable(getClient()));
    when(claimSummaryFeeRepository.findByClaimId(any()))
        .thenReturn(Optional.of(getClaimSummaryFee()));
    when(calculatedFeeDetailRepository.findByClaimId(any()))
        .thenReturn(Optional.of(getCalculatedFeeDetail()));
    when(claimCaseRepository.findByClaimId(any())).thenReturn(Optional.ofNullable(getClaimCase()));
  }

  @State("claims exist for the search criteria")
  public void aClaimExistsForSearchCriteria() {
    log.info("Setting up state: claim exist for the search criteria");
    when(claimRepository.findAll(any(Specification.class), any(Pageable.class)))
        .thenReturn(new PageImpl(Arrays.asList(getClaim(), getClaim())));
    when(claimRepository.findByIdAndSubmissionId(any(), any()))
        .thenReturn(Optional.ofNullable(getClaim()));
    when(clientRepository.findByClaimId(any())).thenReturn(Optional.ofNullable(getClient()));
    when(claimSummaryFeeRepository.findByClaimId(any()))
        .thenReturn(Optional.of(getClaimSummaryFee()));
    when(calculatedFeeDetailRepository.findByClaimId(any()))
        .thenReturn(Optional.of(getCalculatedFeeDetail()));
    when(claimCaseRepository.findByClaimId(any())).thenReturn(Optional.ofNullable(getClaimCase()));
  }

  @State("no claims exist for the search criteria")
  public void noClaimsExistForTheSearchCriteria() {
    log.info("Setting up state: no claims exist for the search criteria");
    when(claimRepository.findAll(any(Specification.class), any(Pageable.class)))
        .thenReturn(new PageImpl(Collections.emptyList()));
  }

  @State("no validation messages exist for the search criteria")
  public void noValidationMessagesExistForTheSearchCriteria() {
    log.info("Setting up state: no validation messages exist for the search criteria");
    when(validationMessageLogRepository.findAll(any(Example.class), any(Pageable.class)))
        .thenReturn(new PageImpl(Collections.emptyList()));
  }

  @State("validation messages exist for the search criteria")
  public void validationMessagesExistForTheSearchCriteria() {
    log.info("Setting up state: validation messages exist for the search criteria");
    when(validationMessageLogRepository.findAll(any(Example.class), any(Pageable.class)))
        .thenReturn(
            new PageImpl(
                Arrays.asList(
                    getValidationMessage(ValidationMessageType.WARNING),
                    getValidationMessage(ValidationMessageType.ERROR))));
  }

  @State("a submission exists for the search criteria")
  public void aSubmissionExistsForSearchCriteria() {
    log.info("Setting up state: a submission exists for the search criteria");
    when(submissionRepository.findAll(any(Specification.class), any(Pageable.class)))
        .thenReturn(new PageImpl(Arrays.asList(getSubmission(), getSubmission())));
  }

  @State("no submissions exist for the search criteria")
  public void noSubmissionExistForTheSearchCriteria() {
    log.info("Setting up state: no submissions exist for the search criteria");
    when(submissionRepository.findAll(any(Specification.class), any(Pageable.class)))
        .thenReturn(new PageImpl(Collections.emptyList()));
  }

  @TargetRequestFilter
  public void requestFilter(HttpRequest request) {
    request.addHeader("Authorization", "00000000-0000-0000-0000-000000000000");
  }

  @TestTemplate
  @ExtendWith(PactVerificationInvocationContextProvider.class)
  void pactVerificationTestTemplate(PactVerificationContext context) {
    context.verifyInteraction();
  }
}
